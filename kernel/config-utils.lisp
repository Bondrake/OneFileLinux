;;;; OneFileLinux Kernel Configuration Utilities
;;;; Tools for managing and manipulating kernel configuration
(defpackage :onefilelinux.kernel.config-utils
  (:use :cl :onefilelinux.core :onefilelinux.config)
  (:export #:parse-kernel-config
           #:write-kernel-config
           #:apply-config-overlay
           #:load-config-overlays
           #:minimize-kernel-config
           #:validate-kernel-config
           #:get-kernel-configs))

(in-package :onefilelinux.kernel.config-utils)

;;; ----------------------------------------------------
;;; Kernel Configuration Management
;;; ----------------------------------------------------

(defclass kernel-config ()
  ((options :initform (make-hash-table :test 'equal)
            :accessor config-options
            :documentation "Hash table of configuration options")
   (comments :initform (make-hash-table :test 'equal)
             :accessor config-comments
             :documentation "Hash table of option comments")
   (ordering :initform '()
             :accessor config-ordering
             :documentation "List to preserve option ordering"))
  (:documentation "Represents a parsed kernel configuration with options and comments."))

(defun parse-kernel-config (file-path)
  "Parse a kernel configuration file into a structured representation."
  (log-message :debug "Parsing kernel config from: ~A" file-path)
  
  (let ((config (make-instance 'kernel-config))
        (current-comment ""))
    
    ;; Read and parse the file line by line
    (with-open-file (in file-path :direction :input)
      (loop for line = (read-line in nil nil)
            while line
            do (let ((trimmed (string-trim '(#\Space #\Tab) line)))
                 (cond
                   ;; Skip empty lines
                   ((string= trimmed ""))
                   
                   ;; Handle comments
                   ((char= (char trimmed 0) #\#)
                    (setf current-comment 
                          (if (string= current-comment "")
                              trimmed
                              (format nil "~A~%~A" current-comment trimmed))))
                   
                   ;; Handle config options
                   (t 
                    (when (or (prefixp "CONFIG_" trimmed)
                             (position #\= trimmed))
                      (let* ((parts (split-string trimmed "="))
                             (key (first parts))
                             (value (second parts)))
                        ;; Store option, comment, and preserve ordering
                        (setf (gethash key (config-options config)) value)
                        (when (not (string= current-comment ""))
                          (setf (gethash key (config-comments config)) current-comment))
                        (push key (config-ordering config))
                        ;; Reset comment accumulator
                        (setf current-comment ""))))))))
    
    ;; Reverse ordering to maintain original order
    (setf (config-ordering config) (nreverse (config-ordering config)))
    
    config))

(defun write-kernel-config (config file-path)
  "Write a kernel configuration to a file."
  (log-message :debug "Writing kernel config to: ~A" file-path)
  
  (with-open-file (out file-path :direction :output
                               :if-exists :supersede
                               :if-does-not-exist :create)
    ;; Write header
    (format out "# Kernel configuration generated by OneFileLinux~%")
    (format out "# Generated on: ~A~%~%" (get-formatted-timestamp))
    
    ;; Write options in original order (or best approximation)
    (dolist (key (config-ordering config))
      (let ((value (gethash key (config-options config)))
            (comment (gethash key (config-comments config))))
        ;; Write comment if available
        (when comment
          (format out "~A~%~%" comment))
        
        ;; Write option
        (format out "~A=~A~%~%" key value)))
    
    ;; Add any options not in original ordering (new options)
    (maphash (lambda (key value)
               (unless (member key (config-ordering config) :test #'string=)
                 (let ((comment (gethash key (config-comments config))))
                   ;; Write comment if available
                   (when comment
                     (format out "~A~%~%" comment))
                   
                   ;; Write option
                   (format out "~A=~A~%~%" key value))))
             (config-options config)))
  
  file-path)

(defun apply-config-overlay (base-config overlay-file)
  "Apply a configuration overlay file to a kernel configuration."
  (log-message :debug "Applying config overlay from: ~A" overlay-file)
  
  ;; Read overlay file
  (with-open-file (in overlay-file :direction :input)
    (loop for line = (read-line in nil nil)
          while line
          do (let ((trimmed (string-trim '(#\Space #\Tab) line)))
               (unless (or (string= trimmed "") 
                          (char= (char trimmed 0) #\#))
                 (let* ((parts (split-string trimmed "="))
                        (key (first parts))
                        (value (second parts)))
                   ;; Apply option to base config
                   (setf (gethash key (config-options base-config)) value)
                   
                   ;; Add to ordering if not already present
                   (unless (member key (config-ordering base-config) :test #'string=)
                     (setf (config-ordering base-config)
                           (append (config-ordering base-config) (list key)))))))))
  
  base-config)

(defun load-config-overlays (base-config-file overlays-dir &key (pattern "*.conf"))
  "Load a base kernel config and apply multiple overlays from a directory."
  (log-message :info "Loading kernel config with overlays from: ~A" overlays-dir)
  
  ;; Parse base config
  (let ((config (parse-kernel-config base-config-file)))
    
    ;; Find and apply overlays
    (dolist (overlay-file (directory (path-join overlays-dir pattern)))
      (log-message :debug "Applying overlay: ~A" (file-namestring overlay-file))
      (apply-config-overlay config overlay-file))
    
    config))

(defun minimize-kernel-config (config dependencies-file &optional output-file)
  "Minimize a kernel configuration by removing unnecessary options based on dependencies."
  (log-message :info "Minimizing kernel configuration")
  
  ;; The implementation would parse dependencies and remove unnecessary options
  ;; This is a simplified version that would be expanded with actual dependency analysis
  
  ;; Read dependency information
  (let ((dependencies (make-hash-table :test 'equal))
        (minimized-config (make-instance 'kernel-config)))
    
    ;; Parse dependencies file
    (with-open-file (in dependencies-file :direction :input)
      (loop for line = (read-line in nil nil)
            while line
            do (let* ((parts (split-string (string-trim '(#\Space #\Tab) line) ":"))
                      (option (first parts))
                      (deps (when (second parts)
                              (split-string (second parts) " "))))
                 (when option
                   (setf (gethash option dependencies) deps)))))
    
    ;; Identify required options
    (let ((required-options '()))
      ;; Start with options explicitly set to 'y' or 'm'
      (maphash (lambda (key value)
                 (when (or (string= value "y") (string= value "m"))
                   (push key required-options)))
               (config-options config))
      
      ;; Add dependencies recursively
      (let ((processed '()))
        (labels ((process-option (opt)
                   (unless (member opt processed :test #'string=)
                     (push opt processed)
                     (let ((deps (gethash opt dependencies)))
                       (when deps
                         (dolist (dep deps)
                           (unless (string= dep "")
                             (push dep required-options)
                             (process-option dep))))))))
          (dolist (opt required-options)
            (process-option opt))))
      
      ;; Create minimized config with only required options
      (dolist (key required-options)
        (let ((value (gethash key (config-options config))))
          (when value
            (setf (gethash key (config-options minimized-config)) value)
            (setf (gethash key (config-comments minimized-config))
                  (gethash key (config-comments config)))
            (push key (config-ordering minimized-config)))))
      
      ;; Reverse to maintain original order
      (setf (config-ordering minimized-config) 
            (nreverse (config-ordering minimized-config)))
      
      ;; Write output if requested
      (when output-file
        (write-kernel-config minimized-config output-file))
      
      minimized-config)))

(defun validate-kernel-config (config)
  "Validate a kernel configuration for consistency and correctness."
  (log-message :info "Validating kernel configuration")
  
  (let ((issues '()))
    ;; Check for common issues
    (maphash (lambda (key value)
               ;; Example validation: ensure critical options are enabled
               (cond
                 ((and (string= key "CONFIG_MODULES") (string= value "n"))
                  (push "Module support disabled, may affect functionality" issues))
                 
                 ((and (string= key "CONFIG_DEVTMPFS") (string= value "n"))
                  (push "DEVTMPFS disabled, may affect device management" issues))
                 
                 ((and (string= key "CONFIG_BLK_DEV_INITRD") (string= value "n"))
                  (push "Initial ramdisk support disabled" issues))))
             (config-options config))
    
    ;; Return validation results
    (if issues
        (progn
          (log-message :warning "Kernel config validation found ~D issues:" (length issues))
          (dolist (issue issues)
            (log-message :warning "  - ~A" issue))
          (values nil issues))
        (progn
          (log-message :info "Kernel configuration validation passed")
          (values t nil)))))

(defun get-kernel-configs (kernel-dir)
  "Get all available kernel configurations in a directory."
  (log-message :debug "Finding kernel configs in: ~A" kernel-dir)
  
  (let ((configs '()))
    ;; Find all .config files
    (dolist (config-file (directory (path-join kernel-dir "*.config")))
      (push (cons (pathname-name config-file) config-file) configs))
    
    ;; Return sorted by name
    (sort configs #'string< :key #'car)))

;;; ----------------------------------------------------
;;; Helper Functions
;;; ----------------------------------------------------

(defun prefixp (prefix string)
  "Check if string starts with prefix."
  (and (>= (length string) (length prefix))
       (string= prefix string :end2 (length prefix))))

(defun get-formatted-timestamp ()
  "Get a formatted timestamp string."
  (multiple-value-bind (second minute hour day month year)
      (get-decoded-time)
    (format nil "~4,'0D-~2,'0D-~2,'0D ~2,'0D:~2,'0D:~2,'0D"
            year month day hour minute second)))