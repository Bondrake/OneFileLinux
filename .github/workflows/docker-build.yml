name: Docker Build

on:
  push:
    branches: [ master, main, dev ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
  pull_request:
    branches: [ master, main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type (minimal, standard, full)'
        required: true
        default: 'standard'
        type: choice
        options:
          - minimal
          - standard
          - full

jobs:
  # Job to determine which builds to run based on trigger type
  setup:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - id: set-matrix
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # For manual triggers, only build the selected type
            echo "matrix={\"include\":[{\"name\":\"${{ github.event.inputs.build_type }}\",\"build_args\":\"${{ github.event.inputs.build_type == 'minimal' && '--minimal' || github.event.inputs.build_type == 'full' && '--full' || '--with-zfs --with-recovery-tools --with-network-tools' }}\"}]}" >> $GITHUB_OUTPUT
          else
            # For automatic triggers, build all types
            echo "matrix={\"include\":[{\"name\":\"minimal\",\"build_args\":\"--minimal\"},{\"name\":\"standard\",\"build_args\":\"--with-zfs --with-recovery-tools --with-network-tools\"},{\"name\":\"full\",\"build_args\":\"--full\"}]}" >> $GITHUB_OUTPUT
          fi

  # Phase 1: Preparation of all files and environment
  prepare:
    needs: setup
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{fromJson(needs.setup.outputs.matrix)}}
      fail-fast: false
    
    name: Prepare Build Environment (${{ matrix.name }})
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Create directories
        run: |
          mkdir -p build-files/alpine-minirootfs
          mkdir -p build-files/linux
          mkdir -p build-files/zfs
          mkdir -p output
      
      # Step 1: Download Alpine Linux
      - name: Download Alpine Linux
        run: |
          echo "::group::Downloading Alpine Linux minirootfs"
          cd build-files
          wget -q --show-progress http://dl-cdn.alpinelinux.org/alpine/v3.21/releases/x86_64/alpine-minirootfs-3.21.3-x86_64.tar.gz
          echo "::endgroup::"
      
      # Step 2: Extract Alpine Linux with proper permissions
      - name: Extract Alpine Linux
        run: |
          echo "::group::Extracting Alpine Linux minirootfs"
          cd build-files
          sudo tar -xzf alpine-minirootfs-3.21.3-x86_64.tar.gz -C alpine-minirootfs
          sudo chown -R $(id -u):$(id -g) alpine-minirootfs
          echo "::endgroup::"
      
      # Step 3: Configure Alpine Linux system
      - name: Configure Alpine Linux
        run: |
          echo "::group::Configuring Alpine Linux"
          cd build-files
          
          # Create runlevel directories with proper permissions
          sudo mkdir -p alpine-minirootfs/etc/runlevels/sysinit
          sudo chmod 777 alpine-minirootfs/etc/runlevels/sysinit
          
          # Create service symlinks
          sudo ln -fs /etc/init.d/mdev alpine-minirootfs/etc/runlevels/sysinit/mdev
          sudo ln -fs /etc/init.d/devfs alpine-minirootfs/etc/runlevels/sysinit/devfs
          sudo ln -fs /etc/init.d/dmesg alpine-minirootfs/etc/runlevels/sysinit/dmesg
          sudo ln -fs /etc/init.d/syslog alpine-minirootfs/etc/runlevels/sysinit/syslog
          sudo ln -fs /etc/init.d/hwdrivers alpine-minirootfs/etc/runlevels/sysinit/hwdrivers
          sudo ln -fs /etc/init.d/networking alpine-minirootfs/etc/runlevels/sysinit/networking
          
          # Set up terminal access
          sudo ln -fs /sbin/agetty alpine-minirootfs/sbin/getty
          
          # Copy configuration files
          mkdir -p zfiles
          # First check if we're in GitHub Actions workspace
          if [ -d "../build/zfiles" ]; then
            echo "Copying zfiles from ../build/zfiles"
            cp -r ../build/zfiles/* zfiles/
          elif [ -d "/onerecovery/build/zfiles" ]; then
            echo "Copying zfiles from /onerecovery/build/zfiles"
            cp -r /onerecovery/build/zfiles/* zfiles/
          fi
          
          # Make sure network directory exists
          sudo mkdir -p alpine-minirootfs/etc/network
          
          # Copy files if they exist
          if [ -f "zfiles/interfaces" ]; then
            sudo cp zfiles/interfaces alpine-minirootfs/etc/network/interfaces
          else
            echo "Creating default interfaces file"
            echo "auto lo" | sudo tee alpine-minirootfs/etc/network/interfaces
            echo "iface lo inet loopback" | sudo tee -a alpine-minirootfs/etc/network/interfaces
          fi
          
          if [ -f "zfiles/resolv.conf" ]; then
            sudo cp zfiles/resolv.conf alpine-minirootfs/etc/resolv.conf
          else
            echo "Creating default resolv.conf"
            echo "nameserver 8.8.8.8" | sudo tee alpine-minirootfs/etc/resolv.conf
          fi
          
          if [ -f "zfiles/profile" ]; then
            sudo cp zfiles/profile alpine-minirootfs/etc/profile
          fi
          
          if [ -f "zfiles/shadow" ]; then
            sudo cp zfiles/shadow alpine-minirootfs/etc/shadow
          fi
          
          if [ -f "zfiles/init" ]; then
            sudo cp zfiles/init alpine-minirootfs/init
            sudo chmod +x alpine-minirootfs/init
          fi
          
          # Install TUI script if included in build type
          if [[ "${{ matrix.build_args }}" != *"--minimal"* ]]; then
            if [ -f "zfiles/onerecovery-tui" ]; then
              sudo cp zfiles/onerecovery-tui alpine-minirootfs/onerecovery-tui
              sudo chmod +x alpine-minirootfs/onerecovery-tui
            else
              echo "TUI script not found, skipping"
            fi
          fi
          
          # Configure console settings
          sudo sed -i 's/^#ttyS0/ttyS0/' alpine-minirootfs/etc/inittab
          sudo sed -i 's|\(/sbin/getty \)|\1 -a root |' alpine-minirootfs/etc/inittab
          
          echo "::endgroup::"
      
      # Step 4: Download Linux kernel
      - name: Download Linux kernel
        run: |
          echo "::group::Downloading Linux kernel"
          cd build-files
          wget -q --show-progress https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.12.19.tar.xz
          echo "::endgroup::"
      
      # Step 5: Extract Linux kernel
      - name: Extract Linux kernel
        run: |
          echo "::group::Extracting Linux kernel"
          cd build-files
          mkdir -p linux
          sudo tar -xf linux-6.12.19.tar.xz --strip-components=1 -C linux
          sudo chown -R $(id -u):$(id -g) linux
          
          # Copy appropriate kernel config based on build type
          if [[ "${{ matrix.build_args }}" == *"--minimal"* ]]; then
            # Check if zfiles directory has the kernel config
            if [ -f "../build/zfiles/kernel-minimal.config" ]; then
              echo "Copying kernel-minimal.config from build/zfiles..."
              cp ../build/zfiles/kernel-minimal.config linux/.config
            else
              echo "WARNING: kernel-minimal.config not found, using default config"
              cd linux
              make defconfig
              cd ..
            fi
          else
            # Check if zfiles directory has the kernel config
            if [ -f "../build/zfiles/.config" ]; then
              echo "Copying .config from build/zfiles..."
              cp ../build/zfiles/.config linux/.config
            else
              echo "WARNING: .config not found, using default config"
              cd linux
              make defconfig
              cd ..
            fi
          fi
          
          # Ensure config is properly set up
          cd linux
          make olddefconfig
          cd ..
          echo "::endgroup::"
      
      # Step 6: Download ZFS if needed
      - name: Download ZFS
        if: matrix.name != 'minimal'
        run: |
          echo "::group::Downloading ZFS"
          cd build-files
          wget -q --show-progress https://github.com/openzfs/zfs/releases/download/zfs-2.3.0/zfs-2.3.0.tar.gz
          echo "::endgroup::"
      
      # Step 7: Extract ZFS if needed
      - name: Extract ZFS
        if: matrix.name != 'minimal'
        run: |
          echo "::group::Extracting ZFS"
          cd build-files
          mkdir -p zfs
          sudo tar -xzf zfs-2.3.0.tar.gz --strip-components=1 -C zfs
          sudo chown -R $(id -u):$(id -g) zfs
          echo "::endgroup::"
      
      # Step 8: Create build script
      - name: Create build script
        run: |
          cat > build-files/build.sh << 'EOF'
          #!/bin/bash
          set -e
          
          # Set up environment variables
          export ONERECOVERY_BUILD_DIR=$(pwd)
          export BUILD_TYPE="$1"
          
          echo "Building OneRecovery with options: $BUILD_TYPE"
          
          # Build the Linux kernel
          cd linux
          echo "::group::Building Linux kernel"
          
          # Ensure kernel config exists
          if [ ! -f ".config" ]; then
            echo "Kernel config missing, creating default config..."
            make defconfig
            make olddefconfig
          fi
          
          # Build kernel
          make -j$(nproc) || exit 1
          echo "::endgroup::"
          
          # Build ZFS if needed
          if [[ "$BUILD_TYPE" != *"--minimal"* ]]; then
            cd ../zfs
            echo "::group::Building ZFS"
            ./autogen.sh
            ./configure --with-linux=../linux
            make -j$(nproc) -C module || exit 1
            echo "::endgroup::"
          fi
          
          # Build the final EFI image
          cd ..
          echo "::group::Building EFI image"
          mkdir -p /onerecovery/output
          
          # Set kernel version
          KERNELVERSION="6.12.19"
          
          # Prepare modules directory
          MODULESPATH="alpine-minirootfs/lib/modules/"
          if [ -d "$MODULESPATH" ]; then
            echo "Clearing existing modules..."
            rm -rf $MODULESPATH/*
          else
            echo "Creating modules directory..."
            mkdir -p $MODULESPATH
          fi
          
          # Install kernel modules
          echo "Installing kernel modules..."
          cd linux
          INSTALL_MOD_PATH="../alpine-minirootfs/"
          make -s modules_install
          
          # Building and installing ZFS modules if enabled
          if [[ "$BUILD_TYPE" != *"--minimal"* ]]; then
            echo "Building ZFS modules..."
            cd ../zfs
            ./configure --with-linux=$(pwd)/../linux --with-linux-obj=$(pwd)/../linux
            make -s -j$(nproc) -C module
            DESTDIR=$(realpath $(pwd)/../alpine-minirootfs)
            mkdir -p ${DESTDIR}/fake
            make DESTDIR=${DESTDIR} INSTALL_MOD_PATH=${DESTDIR} install
            rm -rf ${DESTDIR}/fake
            cd ../linux
          fi
          
          # Creating modules.dep
          echo "Creating modules.dep..."
          depmod -b ../alpine-minirootfs -F System.map $KERNELVERSION
          
          # Copy the kernel image as OneRecovery.efi
          echo "Creating OneRecovery.efi..."
          cp arch/x86/boot/bzImage /onerecovery/output/OneRecovery.efi
          
          # Apply compression if available
          if command -v upx &> /dev/null; then
            echo "Applying UPX compression..."
            cp /onerecovery/output/OneRecovery.efi /onerecovery/output/OneRecovery.efi.original
            if upx --best --lzma /onerecovery/output/OneRecovery.efi; then
              echo "Compression successful"
              COMPRESSED_SIZE=$(du -h /onerecovery/output/OneRecovery.efi | cut -f1)
              echo "Compressed size: $COMPRESSED_SIZE"
            else
              echo "Compression failed, restoring original file"
              mv /onerecovery/output/OneRecovery.efi.original /onerecovery/output/OneRecovery.efi
            fi
            # Clean up backup
            rm -f /onerecovery/output/OneRecovery.efi.original
          else
            echo "UPX not found, skipping compression"
          fi
          
          echo "::endgroup::"
          
          echo "Build complete!"
          EOF
          
          chmod +x build-files/build.sh
      
      # Step 9: Upload prepared files for Phase 2
      - name: Upload prepared files
        uses: actions/upload-artifact@v4
        with:
          name: build-files-${{ matrix.name }}
          path: build-files
          retention-days: 1

  # Phase 2: Build in Docker container
  build:
    needs: [setup, prepare]
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{fromJson(needs.setup.outputs.matrix)}}
      fail-fast: false
    
    name: Build OneRecovery (${{ matrix.name }})
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download prepared files
        uses: actions/download-artifact@v4
        with:
          name: build-files-${{ matrix.name }}
          path: build-files
      
      - name: Set up Docker
        uses: docker/setup-buildx-action@v3
      
      - name: Build Docker image
        run: |
          docker build -t onerecovery-builder ./docker
      
      - name: Build OneRecovery in container
        run: |
          mkdir -p output
          chmod +x build-files/build.sh
          
          # Run the build in Docker with prepared files
          docker run --rm \
            --privileged \
            -v $(pwd)/build-files:/onerecovery/build \
            -v $(pwd)/output:/onerecovery/output \
            onerecovery-builder \
            bash -c "cd /onerecovery/build && ./build.sh \"${{ matrix.build_args }}\""
      
      - name: Check for build artifacts
        id: check_files
        run: |
          if [ -f "./output/OneRecovery.efi" ]; then
            echo "efi_file=true" >> $GITHUB_OUTPUT
            du -h ./output/OneRecovery.efi
          else
            echo "efi_file=false" >> $GITHUB_OUTPUT
            echo "Build failed to produce OneRecovery.efi"
            exit 1
          fi
      
      - name: Upload build artifact
        if: steps.check_files.outputs.efi_file == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: OneRecovery-${{ matrix.name }}
          path: ./output/OneRecovery.efi
          if-no-files-found: error

  # Package all artifacts into a release
  release:
    needs: build
    if: github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts
      
      - name: Create release package
        run: |
          mkdir -p release
          # Only copy files that exist
          if [ -f "./artifacts/OneRecovery-minimal/OneRecovery.efi" ]; then
            cp ./artifacts/OneRecovery-minimal/OneRecovery.efi ./release/OneRecovery-minimal.efi
          fi
          if [ -f "./artifacts/OneRecovery-standard/OneRecovery.efi" ]; then
            cp ./artifacts/OneRecovery-standard/OneRecovery.efi ./release/OneRecovery-standard.efi
          fi
          if [ -f "./artifacts/OneRecovery-full/OneRecovery.efi" ]; then
            cp ./artifacts/OneRecovery-full/OneRecovery.efi ./release/OneRecovery-full.efi
          fi
          cd release
          zip -r OneRecovery-release.zip *.efi
      
      - name: Upload release package
        uses: actions/upload-artifact@v4
        with:
          name: OneRecovery-release
          path: ./release/OneRecovery-release.zip